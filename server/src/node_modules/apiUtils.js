import { query } from "dbUtils"
import { getJson} from "fetchUtils"

const selectQuery = (q, url) => (req, res, next) => query(
	q,
	[req.vars.query],
	async ans => {
		if(ans.length) res.json(await getJson(req.rootUrl +"/"+ url +"/"+ ans[0].id));
		else res.status(404).json({error: "not found"});
	});

const idQuery = q => (req, res, next) => query(
	q,
	[req.vars.id],
	async ans => {
		if(ans.length) res.json({"@self": {url:req.currentUrl, type:"object"},...ans[0]});
		else res.status(404).json({error: "not found"});
	});

const searchQuery = (q, url) => (req, res, next) => query(
	q,
	[req.vars.query],
	async ans => {
		if (ans.length)
			res.json({
				"@self": { url: req.currentUrl, type: "collection" },
				collection: ans.map(item =>req.rootUrl +"/"+ url +"/"+ item.id)
			});
		else res.status(404).json({error: "not found"});
	});

	const deleteQuery = (q, url) => (req, res, next) => query(
		q,
		[req.vars.id],
		async ans => {
			console.log(ans.affectedRows);
			if(ans.length) res.json(await getJson(req.rootUrl +"/"+ url +"/"+ ans[0].id));
			else res.status(404).json({error: "not found"});
		});

//prepares the search terms for querying the DB for the current resource
const prepareOptions = (query, alias) => {
	const options = Object.keys(query).map(element => {
		const decodedQueryElement = JSON.parse(query[element] || "[]");

		if (!Array.isArray(decodedQueryElement))
			return "`" + alias[element] + "` LIKE '" + decodedQueryElement + "'"

		const orValues = decodedQueryElement
			.map(orElement =>
				`\`${alias[element]}\` LIKE '${orElement}'`
		);
		
		if(orValues.length)
			return `(${orValues.join(" OR ")})`;
		else
			return `\`${alias[element]}\` LIKE '0'`;
	}, "").join(" AND ");
	return options?` WHERE ${options}`: "";
}
	
export { selectQuery, idQuery, searchQuery, deleteQuery, prepareOptions };